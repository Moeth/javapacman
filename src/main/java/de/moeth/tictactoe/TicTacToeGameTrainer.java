package de.moeth.tictactoe;

import com.google.common.base.Preconditions;
import lombok.ToString;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <b>Developed by KIT Solutions Pvt. Ltd.</b> (www.kitsol.com) on 24-Aug-16.
 * This program is used for training.(Update the move reward based on the win or loose of the game).
 * Here both player are being played automatically and update probability in AllMoveWithReward.txt.
 * AllMoveWithReward.txt file can be any file containing TicTacToe data generated by running TicTacToeData.java or any other old file
 * updated by this program when run earlier.
 */
public class TicTacToeGameTrainer {

    private static Logger log = LoggerFactory.getLogger(TicTacToeGameTrainer.class);
    private static final int PLAY_TOTAL_GAME = 100;

    private final KIPlayer player1;
    private final KIPlayer player2;

    private TicTacToeGameTrainer(final KIAlgorithm player1, final KIAlgorithm player2) {
        this.player1 = new KIPlayer(player1);
        this.player2 = new KIPlayer(player2);
    }

    public static void main(String[] args) {
        try {
            GameResult gameResult = new TicTacToeGameTrainer(
                    RewardTableAlgoritm.create("AllMoveWithReward1.txt"),
                    RewardTableAlgoritm.create("AllMoveWithReward2.txt")
            ).train(10);

            Preconditions.checkArgument(gameResult.draw == 10);

            GameResult gameResult2 = new TicTacToeGameTrainer(
                    RewardTableAlgoritm.create("AllMoveWithReward1.txt"),
                    new NeuralNetAlgorithm()
            ).train(100);

            Preconditions.checkArgument(gameResult2.draw == 10);
        } catch (Exception e) {
            log.error("", e);
        }
    }

    private GameResult train(final int playTotalGame) {

        // sets a player number for first player  it can be 1 or 2, i.e. X or O.
        int firstPlayerNumber = 0;
        int totalGameCounter = 0;
        GameResult gameResult = new GameResult();
        while (totalGameCounter < playTotalGame) {
                firstPlayerNumber %= 2;
                firstPlayerNumber++;

            play(firstPlayerNumber, gameResult);
            totalGameCounter++;
            }
            saveToFile();
        return gameResult;
    }

    private void play(final int tempMoveType, GameResult gameResult) {

        log.info("train");
        Board board = new Board();
        board.printBoard();

        int moveType = tempMoveType;
        while (board.getGameDecision() == 0) {
            board = getNextBestMove(board, moveType);
            board.printBoard();
            moveType = moveType == 1 ? 2 : 1;
        }

        applyGameResults(board);
        // verifies current game decision (win or draw)
        int gameState = board.getGameDecision();
        gameResult.applyGameState(gameState);
        log.info(
                gameResult.toString() + "\n"
                + "getProbatilityMap: " + player1.getAlgorithm().toString() + " : " + player2.getAlgorithm().toString());
    }

    private Board getNextBestMove(Board board, int playerNumber) {
        int action = getBestMove(board, playerNumber);
        return board.applyAction(playerNumber, action);
    }

    private int getBestMove(final Board board, final int playerNumber) {
        if (playerNumber == 1) {
            return player1.getBestMove(board);
        } else if (playerNumber == 2) {
            return player2.getBestMove(board);
        } else {
            throw new IllegalArgumentException();
        }
    }

    private void applyGameResults(Board board) {
        final int won = board.getGameDecision();
        if (won == 1) {
            log.info("Win player_1");
            player1.updateReward(1); //Win player_1
            player2.updateReward(-1);//loose player_2
        } else if (won == 2) {
            log.info("Win player_2");
            player1.updateReward(-1);//loose player_1
            player2.updateReward(1);//Win player_2
        } else if (won == 3) {
            player1.updateReward(-0.1);
            player2.updateReward(-0.1);
        } else {
            throw new IllegalArgumentException();
        }
    }

    private void saveToFile() {
        player1.saveToFile();
        player2.saveToFile();
    }

    @ToString
    private static class GameResult {

        private int numberOfWinPlayer1 = 0;
        private int numberOfWinPlayer2 = 0;
        private int draw = 0;

        private void applyGameState(final int gameState) {
            log.info("gameState " + gameState);

            // if gameState != 0, means game is finished with a decision
//        if (gameState != 0) {
            if (gameState == 1) {           // player 1 won
                numberOfWinPlayer1++;
            } else if (gameState == 2) {  // player 2 won
                numberOfWinPlayer2++;
            } else {  // game is draw
                draw++;
            }
        }
    }
}

